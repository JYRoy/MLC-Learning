<!DOCTYPE html><html><head>
      <title>01.Triton笔记二：从matrix multiplication看block program</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
      <link rel="stylesheet" href="file:////home/zhangjunyu/.vscode-server/extensions/shd101wyy.markdown-preview-enhanced-0.8.13/crossnote/dependencies/katex/katex.min.css">
      
      
      
      
      
      <style>
      code[class*=language-],pre[class*=language-]{color:#333;background:0 0;font-family:Consolas,"Liberation Mono",Menlo,Courier,monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.4;-moz-tab-size:8;-o-tab-size:8;tab-size:8;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:.8em;overflow:auto;border-radius:3px;background:#f5f5f5}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal;background:#f5f5f5}.token.blockquote,.token.comment{color:#969896}.token.cdata{color:#183691}.token.doctype,.token.macro.property,.token.punctuation,.token.variable{color:#333}.token.builtin,.token.important,.token.keyword,.token.operator,.token.rule{color:#a71d5d}.token.attr-value,.token.regex,.token.string,.token.url{color:#183691}.token.atrule,.token.boolean,.token.code,.token.command,.token.constant,.token.entity,.token.number,.token.property,.token.symbol{color:#0086b3}.token.prolog,.token.selector,.token.tag{color:#63a35c}.token.attr-name,.token.class,.token.class-name,.token.function,.token.id,.token.namespace,.token.pseudo-class,.token.pseudo-element,.token.url-reference .token.variable{color:#795da3}.token.entity{cursor:help}.token.title,.token.title .token.punctuation{font-weight:700;color:#1d3e81}.token.list{color:#ed6a43}.token.inserted{background-color:#eaffea;color:#55a532}.token.deleted{background-color:#ffecec;color:#bd2c00}.token.bold{font-weight:700}.token.italic{font-style:italic}.language-json .token.property{color:#183691}.language-markup .token.tag .token.punctuation{color:#333}.language-css .token.function,code.language-css{color:#0086b3}.language-yaml .token.atrule{color:#63a35c}code.language-yaml{color:#183691}.language-ruby .token.function{color:#333}.language-markdown .token.url{color:#795da3}.language-makefile .token.symbol{color:#795da3}.language-makefile .token.variable{color:#183691}.language-makefile .token.builtin{color:#0086b3}.language-bash .token.keyword{color:#0086b3}pre[data-line]{position:relative;padding:1em 0 1em 3em}pre[data-line] .line-highlight-wrapper{position:absolute;top:0;left:0;background-color:transparent;display:block;width:100%}pre[data-line] .line-highlight{position:absolute;left:0;right:0;padding:inherit 0;margin-top:1em;background:hsla(24,20%,50%,.08);background:linear-gradient(to right,hsla(24,20%,50%,.1) 70%,hsla(24,20%,50%,0));pointer-events:none;line-height:inherit;white-space:pre}pre[data-line] .line-highlight:before,pre[data-line] .line-highlight[data-end]:after{content:attr(data-start);position:absolute;top:.4em;left:.6em;min-width:1em;padding:0 .5em;background-color:hsla(24,20%,50%,.4);color:#f4f1ef;font:bold 65%/1.5 sans-serif;text-align:center;vertical-align:.3em;border-radius:999px;text-shadow:none;box-shadow:0 1px #fff}pre[data-line] .line-highlight[data-end]:after{content:attr(data-end);top:auto;bottom:.4em}html body{font-family:'Helvetica Neue',Helvetica,'Segoe UI',Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ol,html body>ul{margin-bottom:16px}html body ol,html body ul{padding-left:2em}html body ol.no-list,html body ul.no-list{padding:0;list-style-type:none}html body ol ol,html body ol ul,html body ul ol,html body ul ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;background-color:#f0f0f0;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:700;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:700}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::after,html body code::before{letter-spacing:-.2em;content:'\00a0'}html body pre>code{padding:0;margin:0;word-break:normal;white-space:pre;background:0 0;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:after,html body pre code:before,html body pre tt:after,html body pre tt:before{content:normal}html body blockquote,html body dl,html body ol,html body p,html body pre,html body ul{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body code,html body pre{word-wrap:break-word;white-space:pre}}.markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview ul{list-style:disc}.markdown-preview ul ul{list-style:circle}.markdown-preview ul ul ul{list-style:square}.markdown-preview ol{list-style:decimal}.markdown-preview ol ol,.markdown-preview ul ol{list-style-type:lower-roman}.markdown-preview ol ol ol,.markdown-preview ol ul ol,.markdown-preview ul ol ol,.markdown-preview ul ul ol{list-style-type:lower-alpha}.markdown-preview .newpage,.markdown-preview .pagebreak{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center!important}.markdown-preview:not([data-for=preview]) .code-chunk .code-chunk-btn-group{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .status{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .output-div{margin-bottom:16px}.markdown-preview .md-toc{padding:0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link div,.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}.markdown-preview .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0;min-height:100vh}@media screen and (min-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px + 2em)}}@media screen and (max-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{font-size:14px!important;padding:1em}}@media print{html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc{padding:0 16px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link div,html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% - 300px);padding:2em calc(50% - 457px - 300px / 2);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}
/* Please visit the URL below for more information: */
/*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */

      </style>
      <!-- The content below will be included at the end of the <head> element. --><script type="text/javascript">
  document.addEventListener("DOMContentLoaded", function () {
    // your code here
  });
</script></head><body for="html-export">
    
    
      <div class="crossnote markdown-preview  ">
      
<h1 id="triton笔记二">Triton笔记二 </h1>
<ul>
<li><a href="#triton%E7%AC%94%E8%AE%B0%E4%BA%8C">Triton笔记二</a>
<ul>
<li><a href="#motivations">Motivations</a></li>
<li><a href="#compute-kernel">Compute Kernel</a>
<ul>
<li><a href="#pointer-arithmetic">Pointer Arithmetic</a></li>
<li><a href="#l2-cache-optimizations">L2 Cache Optimizations</a></li>
</ul>
</li>
<li><a href="#%E5%AE%9E%E7%8E%B0">实现</a>
<ul>
<li><a href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89">函数定义</a></li>
<li><a href="#program-%E6%A6%82%E5%BF%B5">Program 概念</a></li>
<li><a href="#block-%E6%A6%82%E5%BF%B5">Block 概念</a></li>
</ul>
</li>
<li><a href="#references">References</a></li>
</ul>
</li>
</ul>
<h2 id="motivations">Motivations </h2>
<p>传统的情况下，我们开发应用会选择使用厂商提供的计算库中的矩阵乘计算，例如cublas库，但是这种类型的库通常都是不开源的，对于现在更加多样的深度学习场景，我们很难去二次开发它。</p>
<p>相比之下，Triton的优势就非常的明显了，我们可以轻松的使用它来开发一些fused kernel，最典型的就是把activation和matrix multiplication结合起来。</p>
<p>对于MM的优化，其实大概的思路都差不多，因为总的计算量一定是不变的，所以能做的事情就是尽可能地使用shared memory，提高cache hit rate。</p>
<p>cache hit rate 理解为shared memory(L1 Cache)每次要到global memory找需要的数据时，会先去L2 Cache看是否存在，如果有就不用再去global memory了，有的概率越高，意味着cache hit rate越高。</p>
<p>所以我们希望尽可能的利用SRAM，但是因为它的空间比较小，所以基本原则是：每次往SRAM移动的数据，都要尽可能的被利用，避免来来回回搬迁。</p>
<h2 id="compute-kernel">Compute Kernel </h2>
<p>首先通过伪代码来看Triton中的(M, K) * (K, N)的矩阵乘的blocked算法。</p>
<pre data-role="codeBlock" data-info="python" class="language-python python"><code><span class="token keyword keyword-for">for</span> m <span class="token keyword keyword-in">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> M<span class="token punctuation">,</span> BLOCK_SIZE_M<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword keyword-for">for</span> n <span class="token keyword keyword-in">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> N<span class="token punctuation">,</span> BLOCK_SIZE_N<span class="token punctuation">)</span><span class="token punctuation">:</span>
        acc <span class="token operator">=</span> zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>BLOCK_SIZE_M<span class="token punctuation">,</span> BLOCK_SIZE_N<span class="token punctuation">)</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>float32<span class="token punctuation">)</span>
        <span class="token keyword keyword-for">for</span> k <span class="token keyword keyword-in">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> K<span class="token punctuation">,</span> BLOCK_SIZE_K<span class="token punctuation">)</span><span class="token punctuation">:</span>
            a <span class="token operator">=</span> A<span class="token punctuation">[</span>m <span class="token punctuation">:</span> m<span class="token operator">+</span>BLOCK_SIZE_M<span class="token punctuation">,</span> k <span class="token punctuation">:</span> k<span class="token operator">+</span>BLOCK_SIZE_K<span class="token punctuation">]</span>
            b <span class="token operator">=</span> B<span class="token punctuation">[</span>k <span class="token punctuation">:</span> k<span class="token operator">+</span>BLOCK_SIZE_K<span class="token punctuation">,</span> n <span class="token punctuation">:</span> n<span class="token operator">+</span>BLOCK_SIZE_N<span class="token punctuation">]</span>
            acc <span class="token operator">+=</span> dot<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
        C<span class="token punctuation">[</span>m <span class="token punctuation">:</span> m<span class="token operator">+</span>BLOCK_SIZE_M<span class="token punctuation">,</span> n <span class="token punctuation">:</span> n<span class="token operator">+</span>BLOCK_SIZE_N<span class="token punctuation">]</span> <span class="token operator">=</span> acc
</code></pre><p>其中主要的点在于，最内层的循环中需要从A、B矩阵中读出block块。因此，在这里需要引入multi-dimensional pointer运算。</p>
<h3 id="pointer-arithmetic">Pointer Arithmetic </h3>
<p>对于行主序的2D矩阵x，想要通过指针来访问对应下标中的元素，公式为：</p>
<pre data-role="codeBlock" data-info="python" class="language-python python"><code>X<span class="token punctuation">[</span>i<span class="token punctuation">,</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> X_ptr <span class="token operator">+</span> i <span class="token operator">*</span> stride_xi <span class="token operator">+</span> j <span class="token operator">*</span> stride_xj
</code></pre><p>因此，如果要访问一个block的元素，采用类似的</p>
<pre data-role="codeBlock" data-info="python" class="language-python python"><code><span class="token operator">&amp;</span>A<span class="token punctuation">[</span>m <span class="token punctuation">:</span> m<span class="token operator">+</span>BLOCK_SIZE_M<span class="token punctuation">,</span> k<span class="token punctuation">:</span>k<span class="token operator">+</span>BLOCK_SIZE_K<span class="token punctuation">]</span> <span class="token operator">=</span>  a_ptr <span class="token operator">+</span> <span class="token punctuation">(</span>m <span class="token punctuation">:</span> m<span class="token operator">+</span>BLOCK_SIZE_M<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span><span class="token operator">*</span>A<span class="token punctuation">.</span>stride<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>k <span class="token punctuation">:</span> k<span class="token operator">+</span>BLOCK_SIZE_K<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">*</span>A<span class="token punctuation">.</span>stride<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>B<span class="token punctuation">[</span>k <span class="token punctuation">:</span> k<span class="token operator">+</span>BLOCK_SIZE_K<span class="token punctuation">,</span> n<span class="token punctuation">:</span>n<span class="token operator">+</span>BLOCK_SIZE_N<span class="token punctuation">]</span> <span class="token operator">=</span>  b_ptr <span class="token operator">+</span> <span class="token punctuation">(</span>k <span class="token punctuation">:</span> k<span class="token operator">+</span>BLOCK_SIZE_K<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span><span class="token operator">*</span>B<span class="token punctuation">.</span>stride<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>n <span class="token punctuation">:</span> n<span class="token operator">+</span>BLOCK_SIZE_N<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">*</span>B<span class="token punctuation">.</span>stride<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>接下来就是Triton的实现，这里要注意的是Triton中M、N必须要是BLOCK_SIZE_M和BLOCK_SIZE_N的整数倍，如果不是的话，则需要一些空值来填充。</p>
<pre data-role="codeBlock" data-info="python" class="language-python python"><code>offs_am <span class="token operator">=</span> <span class="token punctuation">(</span>pid_m <span class="token operator">*</span> BLOCK_SIZE_M <span class="token operator">+</span> tl<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> BLOCK_SIZE_M<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> M
offs_bn <span class="token operator">=</span> <span class="token punctuation">(</span>pid_n <span class="token operator">*</span> BLOCK_SIZE_N <span class="token operator">+</span> tl<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> BLOCK_SIZE_N<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> N
offs_k <span class="token operator">=</span> tl<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> BLOCK_SIZE_K<span class="token punctuation">)</span>
a_ptrs <span class="token operator">=</span> a_ptr <span class="token operator">+</span> <span class="token punctuation">(</span>offs_am<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span><span class="token operator">*</span>stride_am <span class="token operator">+</span> offs_k <span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">*</span>stride_ak<span class="token punctuation">)</span>
b_ptrs <span class="token operator">=</span> b_ptr <span class="token operator">+</span> <span class="token punctuation">(</span>offs_k <span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span><span class="token operator">*</span>stride_bk <span class="token operator">+</span> offs_bn<span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">*</span>stride_bn<span class="token punctuation">)</span>
a_ptrs <span class="token operator">+=</span> BLOCK_SIZE_K <span class="token operator">*</span> stride_ak<span class="token punctuation">;</span>
b_ptrs <span class="token operator">+=</span> BLOCK_SIZE_K <span class="token operator">*</span> stride_bk<span class="token punctuation">;</span>
</code></pre><h3 id="l2-cache-optimizations">L2 Cache Optimizations </h3>
<p>每一个program可以计算得到c中的一个[BLOCK_SIZE_M, BLOCK_SIZE_N]的block。</p>
<p>为了保证L2 Cache的命中率，这些block的顺序非常重要，但不幸的是，对于简单的行主序不会切分它，一个原始的triton实现如下：</p>
<pre data-role="codeBlock" data-info="python" class="language-python python"><code><span class="token decorator annotation punctuation">@triton<span class="token punctuation">.</span>jit</span>
<span class="token keyword keyword-def">def</span> <span class="token function">matmul</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> C<span class="token punctuation">,</span> M<span class="token punctuation">,</span> N<span class="token punctuation">,</span> K<span class="token punctuation">,</span> stride_am<span class="token punctuation">,</span> stride_ak<span class="token punctuation">,</span> 
            stride_bk<span class="token punctuation">,</span> stride_bn<span class="token punctuation">,</span> stride_cm<span class="token punctuation">,</span> stride_cn<span class="token punctuation">,</span>
            <span class="token operator">**</span>META<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># extract metaparameters</span>
    BLOCK_M<span class="token punctuation">,</span> GROUP_M <span class="token operator">=</span> META<span class="token punctuation">[</span><span class="token string">'BLOCK_M'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> META<span class="token punctuation">[</span><span class="token string">'GROUP_M'</span><span class="token punctuation">]</span>
    BLOCK_N <span class="token operator">=</span> META<span class="token punctuation">[</span><span class="token string">'BLOCK_N'</span><span class="token punctuation">]</span>
    BLOCK_K <span class="token operator">=</span> META<span class="token punctuation">[</span><span class="token string">'BLOCK_K'</span><span class="token punctuation">]</span>
    <span class="token comment"># programs are grouped together to improve L2 hit rate</span>
    _pid_m <span class="token operator">=</span> tl<span class="token punctuation">.</span>program_id<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
    _pid_n <span class="token operator">=</span> tl<span class="token punctuation">.</span>program_id<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    pid_m <span class="token operator">=</span> _pid_m <span class="token operator">//</span> GROUP_M
    pid_n <span class="token operator">=</span> <span class="token punctuation">(</span>_pid_n <span class="token operator">*</span> GROUP_M<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>_pid_m <span class="token operator">%</span> GROUP_M<span class="token punctuation">)</span>
    <span class="token comment"># rm (resp. rn) denotes a range of indices</span>
    <span class="token comment"># for rows (resp. col) of C</span>
    rm <span class="token operator">=</span> pid_m <span class="token operator">*</span> BLOCK_M <span class="token operator">+</span> tl<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> BLOCK_M<span class="token punctuation">)</span>
    rn <span class="token operator">=</span> pid_n <span class="token operator">*</span> BLOCK_N <span class="token operator">+</span> tl<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> BLOCK_N<span class="token punctuation">)</span>
    <span class="token comment"># rk denotes a range of indices for columns </span>
    <span class="token comment"># (resp. rows) of A (resp. B)</span>
    rk <span class="token operator">=</span> tl<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> BLOCK_K<span class="token punctuation">)</span>
    <span class="token comment"># the memory addresses of elements in the first block of</span>
    <span class="token comment"># A and B can be computed using numpy-style broadcasting</span>
    A <span class="token operator">=</span> A <span class="token operator">+</span> <span class="token punctuation">(</span>rm<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span> <span class="token operator">*</span> stride_am <span class="token operator">+</span> rk<span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">*</span> stride_ak<span class="token punctuation">)</span>
    B <span class="token operator">=</span> B <span class="token operator">+</span> <span class="token punctuation">(</span>rk <span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span> <span class="token operator">*</span> stride_bk  <span class="token operator">+</span> rn<span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">*</span> stride_bn<span class="token punctuation">)</span>
    <span class="token comment"># initialize and iteratively update accumulator</span>
    acc <span class="token operator">=</span> tl<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>BLOCK_M<span class="token punctuation">,</span> BLOCK_N<span class="token punctuation">)</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>tl<span class="token punctuation">.</span>float32<span class="token punctuation">)</span>
    <span class="token keyword keyword-for">for</span> k <span class="token keyword keyword-in">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>K<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>BLOCK_K<span class="token punctuation">)</span><span class="token punctuation">:</span>
        a <span class="token operator">=</span> tl<span class="token punctuation">.</span>load<span class="token punctuation">(</span>A<span class="token punctuation">)</span>
        b <span class="token operator">=</span> tl<span class="token punctuation">.</span>load<span class="token punctuation">(</span>B<span class="token punctuation">)</span>
        <span class="token comment"># block level matrix multiplication</span>
        acc <span class="token operator">+=</span> tl<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
        <span class="token comment"># increment pointers so that the next blocks of A and B</span>
        <span class="token comment"># are loaded during the next iteration</span>
        A <span class="token operator">+=</span> BLOCK_K <span class="token operator">*</span> stride_ak
        B <span class="token operator">+=</span> BLOCK_K <span class="token operator">*</span> stride_bk
    <span class="token comment"># fuse leaky ReLU if desired</span>
    <span class="token comment"># acc = tl.where(acc &gt;= 0, acc, alpha * acc)</span>
    <span class="token comment"># write back result</span>
    C <span class="token operator">=</span> C <span class="token operator">+</span> <span class="token punctuation">(</span>rm<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span> <span class="token operator">*</span> stride_cm <span class="token operator">+</span> rn<span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">*</span> stride_cn<span class="token punctuation">)</span>
    mask <span class="token operator">=</span> <span class="token punctuation">(</span>rm<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> M<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>rn<span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> N<span class="token punctuation">)</span>
    tl<span class="token punctuation">.</span>store<span class="token punctuation">(</span>C<span class="token punctuation">,</span> acc<span class="token punctuation">,</span> mask<span class="token operator">=</span>mask<span class="token punctuation">)</span>
</code></pre><p>一种可能的解决方案是按照促进数据重用的顺序启动block。triton可以通过在切换到下一列之前的super-grouping block来完成：</p>
<pre data-role="codeBlock" data-info="python" class="language-python python"><code><span class="token comment"># Program ID</span>
pid <span class="token operator">=</span> tl<span class="token punctuation">.</span>program_id<span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token comment"># Number of program ids along the M axis</span>
num_pid_m <span class="token operator">=</span> tl<span class="token punctuation">.</span>cdiv<span class="token punctuation">(</span>M<span class="token punctuation">,</span> BLOCK_SIZE_M<span class="token punctuation">)</span>
<span class="token comment"># Number of programs ids along the N axis</span>
num_pid_n <span class="token operator">=</span> tl<span class="token punctuation">.</span>cdiv<span class="token punctuation">(</span>N<span class="token punctuation">,</span> BLOCK_SIZE_N<span class="token punctuation">)</span>
<span class="token comment"># Number of programs in group</span>
num_pid_in_group <span class="token operator">=</span> GROUP_SIZE_M <span class="token operator">*</span> num_pid_n
<span class="token comment"># Id of the group this program is in</span>
group_id <span class="token operator">=</span> pid <span class="token operator">//</span> num_pid_in_group
<span class="token comment"># Row-id of the first program in the group</span>
first_pid_m <span class="token operator">=</span> group_id <span class="token operator">*</span> GROUP_SIZE_M
<span class="token comment"># If `num_pid_m` isn't divisible by `GROUP_SIZE_M`, the last group is smaller</span>
group_size_m <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>num_pid_m <span class="token operator">-</span> first_pid_m<span class="token punctuation">,</span> GROUP_SIZE_M<span class="token punctuation">)</span>
<span class="token comment"># *Within groups*, programs are ordered in a column-major order</span>
<span class="token comment"># Row-id of the program in the *launch grid*</span>
pid_m <span class="token operator">=</span> first_pid_m <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid <span class="token operator">%</span> num_pid_in_group<span class="token punctuation">)</span> <span class="token operator">%</span> group_size_m<span class="token punctuation">)</span>
<span class="token comment"># Col-id of the program in the *launch grid*</span>
pid_n <span class="token operator">=</span> <span class="token punctuation">(</span>pid <span class="token operator">%</span> num_pid_in_group<span class="token punctuation">)</span> <span class="token operator">//</span> group_size_m
</code></pre><p>这样看代码还是很抽象，但是可视化来看，就非常的清楚了：</p>
<ol>
<li>行主序（row-major ordering）：读入90个block，写9个block</li>
<li>组序（grouped ordering）：读入54个block，写9个block</li>
</ol>
<p><img src="../.images/grouped_vs_row_major_ordering.png" alt="grouped_vs_row_major_ordering.png"></p>
<h2 id="实现">实现 </h2>
<h3 id="函数定义">函数定义 </h3>
<pre data-role="codeBlock" data-info="python" class="language-python python"><code><span class="token decorator annotation punctuation">@triton<span class="token punctuation">.</span>jit</span>
<span class="token keyword keyword-def">def</span> <span class="token function">matmul_kernel</span><span class="token punctuation">(</span>
    <span class="token comment"># Pointers to matrices</span>
    a_ptr<span class="token punctuation">,</span>
    b_ptr<span class="token punctuation">,</span>
    c_ptr<span class="token punctuation">,</span>
    <span class="token comment"># Matrix dimensions</span>
    M<span class="token punctuation">,</span>
    N<span class="token punctuation">,</span>
    K<span class="token punctuation">,</span>
    <span class="token comment"># The stride variables represent how much to increase the ptr by when moving by 1</span>
    <span class="token comment"># element in a particular dimension. E.g. `stride_am` is how much to increase `a_ptr`</span>
    <span class="token comment"># by to get the element one row down (A has M rows).</span>
    stride_am<span class="token punctuation">,</span>
    stride_ak<span class="token punctuation">,</span>  <span class="token comment">#</span>
    stride_bk<span class="token punctuation">,</span>
    stride_bn<span class="token punctuation">,</span>  <span class="token comment">#</span>
    stride_cm<span class="token punctuation">,</span>
    stride_cn<span class="token punctuation">,</span>
    <span class="token comment"># Meta-parameters</span>
    BLOCK_SIZE_M<span class="token punctuation">:</span> tl<span class="token punctuation">.</span>constexpr<span class="token punctuation">,</span>
    BLOCK_SIZE_N<span class="token punctuation">:</span> tl<span class="token punctuation">.</span>constexpr<span class="token punctuation">,</span>
    BLOCK_SIZE_K<span class="token punctuation">:</span> tl<span class="token punctuation">.</span>constexpr<span class="token punctuation">,</span>  <span class="token comment">#</span>
    GROUP_SIZE_M<span class="token punctuation">:</span> tl<span class="token punctuation">.</span>constexpr<span class="token punctuation">,</span>  <span class="token comment">#</span>
    ACTIVATION<span class="token punctuation">:</span> tl<span class="token punctuation">.</span>constexpr<span class="token punctuation">,</span>  <span class="token comment">#</span>
<span class="token punctuation">)</span>
</code></pre><ol>
<li><code>a_ptr</code>、<code>b_ptr</code>、<code>c_ptr</code>：tensor的指针，第一个元素的地址；</li>
<li>strides：和我们在torch中看到的stride是同一个概念，strid0对应0维+1需要的stride，stride1对应1维+1需要的stride，如果shape是一个(3,4)的tensor，那么它的stride是(4,1)；</li>
<li>Meta-parameters：剩下的tl.constexpr都是超参数l，在triton中超参数通过triton.Config和triton.autotune来设置；</li>
</ol>
<h3 id="program-概念">Program 概念 </h3>
<pre data-role="codeBlock" data-info="python" class="language-python python"><code>pid <span class="token operator">=</span> tl<span class="token punctuation">.</span>program_id<span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>
</code></pre><p>这是在vector add用例中就已经看过的内容。在kernel中，写成只处理C的一部分输出的形式，但是执行完kernel后可以得到完成的C的原因，就是program在发挥它的作用。</p>
<p>program其实可以理解成循环，program_id理解成循环的index。</p>
<p>axis理解为嵌套的循环中有第几层循环，axis=0意味着只有一层循环，axis=1意味着有两层嵌套的循环，以此类推。</p>
<p>这个program在什么时候决定它到底有几层呢？其实不是在axis这里，这里可以理解为取出index。真正的设置循环的层数的地方在host代码中调用kernel的位置。</p>
<p>也就是这里的grid，它被定义为了一个lambda函数，它的值和输入x的M、N维度以及BLOCK_SIZE有关系，是一个一维值。能够和kernel内的axis=0对应上，都是一层的。</p>
<pre data-role="codeBlock" data-info="python" class="language-python python"><code>grid <span class="token operator">=</span> <span class="token keyword keyword-lambda">lambda</span> META<span class="token punctuation">:</span> <span class="token punctuation">(</span>
    triton<span class="token punctuation">.</span>cdiv<span class="token punctuation">(</span>M<span class="token punctuation">,</span> META<span class="token punctuation">[</span><span class="token string">"BLOCK_SIZE_M"</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> triton<span class="token punctuation">.</span>cdiv<span class="token punctuation">(</span>N<span class="token punctuation">,</span> META<span class="token punctuation">[</span><span class="token string">"BLOCK_SIZE_N"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span>
matmul_kernel<span class="token punctuation">[</span>grid<span class="token punctuation">]</span><span class="token punctuation">(</span>
    a<span class="token punctuation">,</span>
    b<span class="token punctuation">,</span>
    c<span class="token punctuation">,</span>  <span class="token comment">#</span>
    M<span class="token punctuation">,</span>
    N<span class="token punctuation">,</span>
    K<span class="token punctuation">,</span>  <span class="token comment">#</span>
    a<span class="token punctuation">.</span>stride<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    a<span class="token punctuation">.</span>stride<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment">#</span>
    b<span class="token punctuation">.</span>stride<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    b<span class="token punctuation">.</span>stride<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment">#</span>
    c<span class="token punctuation">.</span>stride<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    c<span class="token punctuation">.</span>stride<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment">#</span>
    ACTIVATION<span class="token operator">=</span>activation<span class="token punctuation">,</span>  <span class="token comment">#</span>
<span class="token punctuation">)</span>
</code></pre><h3 id="block-概念">Block 概念 </h3>
<p>Block的概念，就是建立在program基础之上。</p>
<p>前面说了program理解为循环，每一个index对应了输出C矩阵中的一部分，这一部分就是我们说的block，block的大小是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>B</mi><mi>L</mi><mi>O</mi><mi>C</mi><mi>K</mi><mi mathvariant="normal">_</mi><mi>S</mi><mi>I</mi><mi>Z</mi><mi>E</mi><mi mathvariant="normal">_</mi><mi>M</mi></mrow><mo>×</mo><mrow><mi>B</mi><mi>L</mi><mi>O</mi><mi>C</mi><mi>K</mi><mi mathvariant="normal">_</mi><mi>S</mi><mi>I</mi><mi>Z</mi><mi>E</mi><mi mathvariant="normal">_</mi><mi>N</mi></mrow></mrow><annotation encoding="application/x-tex">{BLOCK\_SIZE\_M} \times {BLOCK\_SIZE\_N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.07153em;">OC</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.05764em;">ZE</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.07153em;">OC</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.05764em;">ZE</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></span>，则循环的次数就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>M</mi><mrow><mi>B</mi><mi>L</mi><mi>O</mi><mi>C</mi><mi>K</mi><mi mathvariant="normal">_</mi><mi>S</mi><mi>I</mi><mi>Z</mi><mi>E</mi><mi mathvariant="normal">_</mi><mi>M</mi></mrow></mfrac><mo>×</mo><mfrac><mi>N</mi><mrow><mi>B</mi><mi>L</mi><mi>O</mi><mi>C</mi><mi>K</mi><mi mathvariant="normal">_</mi><mi>S</mi><mi>I</mi><mi>Z</mi><mi>E</mi><mi mathvariant="normal">_</mi><mi>N</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{M}{BLOCK\_SIZE\_M} \times \frac{N}{BLOCK\_SIZE\_N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4343em;vertical-align:-0.562em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span><span class="mord mathnormal mtight">L</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">OC</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span><span class="mord mtight" style="margin-right:0.02778em;">_</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">ZE</span><span class="mord mtight" style="margin-right:0.02778em;">_</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.562em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.4343em;vertical-align:-0.562em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span><span class="mord mathnormal mtight">L</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">OC</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span><span class="mord mtight" style="margin-right:0.02778em;">_</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">ZE</span><span class="mord mtight" style="margin-right:0.02778em;">_</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.562em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。这里也就是我们上面看到的grid的计算公式，即grid=81。</p>
<p>也就是说，完成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>×</mo><mi>B</mi><mo>=</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">A\times B=C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>，A的大小是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>×</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">M \times K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>，B的大小是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>×</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">K \times N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>，的运算，我们需要</p>
<p>所以，从block的角度，就是上面的super grouped ordering：先计算9个blocks，组合成一个大的super block，在进行下一个super block。</p>
<p>它的好处就是：</p>
<ol>
<li>同样都是计算9个block，读入的block更少</li>
<li>cache hit rate更高</li>
</ol>
<p>对于输出C，它需要计算0到80的81个block。当program在axis=0维度上递增时，我们期望形成一下的代码逻辑： (pid_m, pid_n) 是黄色小块的坐标,</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-for">for</span> pid in <span class="token function">range</span><span class="token punctuation">(</span><span class="token number">81</span><span class="token punctuation">)</span><span class="token operator">:</span>
    pid <span class="token operator">--</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>pid_m<span class="token punctuation">,</span> pid_n<span class="token punctuation">)</span>
</code></pre><p>对应到triton中的实现，我们要做的就是把pid转换为pid_m和pid_n</p>
<pre data-role="codeBlock" data-info="python" class="language-python python"><code>num_pid_m <span class="token operator">=</span> tl<span class="token punctuation">.</span>cdiv<span class="token punctuation">(</span>M<span class="token punctuation">,</span> BLOCK_SIZE_M<span class="token punctuation">)</span>
num_pid_n <span class="token operator">=</span> tl<span class="token punctuation">.</span>cdiv<span class="token punctuation">(</span>N<span class="token punctuation">,</span> BLOCK_SIZE_N<span class="token punctuation">)</span>
num_pid_in_group <span class="token operator">=</span> GROUP_SIZE_M <span class="token operator">*</span> num_pid_n
group_id <span class="token operator">=</span> pid <span class="token operator">//</span> num_pid_in_group
first_pid_m <span class="token operator">=</span> group_id <span class="token operator">*</span> GROUP_SIZE_M
group_size_m <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>num_pid_m <span class="token operator">-</span> first_pid_m<span class="token punctuation">,</span> GROUP_SIZE_M<span class="token punctuation">)</span>
pid_m <span class="token operator">=</span> first_pid_m <span class="token operator">+</span> <span class="token punctuation">(</span>pid <span class="token operator">%</span> group_size_m<span class="token punctuation">)</span>
pid_n <span class="token operator">=</span> <span class="token punctuation">(</span>pid <span class="token operator">%</span> num_pid_in_group<span class="token punctuation">)</span> <span class="token operator">//</span> group_size_m
</code></pre><ul>
<li>num_pid_m和num_pd_n：C矩阵长宽两个维度各组有多少的block</li>
<li>num_pid_in_group：下图中红框部分的block数，高GROUP_SIZE_M，宽num_pid_n。对应一个红框内的block，它们会依次计算
<ul>
<li><img src="../.images/grouped%20ordering%20num_pid_in_group.png" alt="grouped ordering num_pid_in_group.png"></li>
</ul>
</li>
<li>group_id：红色框的id，当前pid在第几个框里</li>
<li>first_pid_m：当前group在m维度上的第一个pid是多少</li>
<li>group_id：因为最后一个group可能不满，所以需要获取当前pid的实际group size m</li>
<li>pid_m和pid_n：是我们最后想要的值，当前pid（当前循环）在第几个block上
<ul>
<li>pid_m一定是小于first_pid_m + first_pid_m的</li>
</ul>
</li>
</ul>
<p>前面还是从高层的角度看block和super group。下面深入到一个block中，也就是triton kernel实现的角度。</p>
<p><img src="../.images/one%20block%20computation.png" alt="one block computation.png"></p>
<p>A中第一行的9个block和B中第一列的9个block逐个相乘，放入accumulator累加器中，9个block计算完，也就得到了C中的第一个block。</p>
<p>这个过程意味着我们还要关注到A和B中的9个block，每个block有多少个元素，每个元素的指针地址是多少哦</p>
<pre data-role="codeBlock" data-info="python" class="language-python python"><code><span class="token comment"># ----------------------------------------------------------</span>
<span class="token comment"># Create pointers for the first blocks of A and B.</span>
<span class="token comment"># We will advance this pointer as we move in the K direction</span>
<span class="token comment"># and accumulate</span>
<span class="token comment"># `a_ptrs` is a block of [BLOCK_SIZE_M, BLOCK_SIZE_K] pointers</span>
<span class="token comment"># `b_ptrs` is a block of [BLOCK_SIZE_K, BLOCK_SIZE_N] pointers</span>
<span class="token comment"># See above `Pointer Arithmetics` section for details</span>
offs_am <span class="token operator">=</span> <span class="token punctuation">(</span>pid_m <span class="token operator">*</span> BLOCK_SIZE_M <span class="token operator">+</span> tl<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> BLOCK_SIZE_M<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> M
offs_bn <span class="token operator">=</span> <span class="token punctuation">(</span>pid_n <span class="token operator">*</span> BLOCK_SIZE_N <span class="token operator">+</span> tl<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> BLOCK_SIZE_N<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> N
offs_k <span class="token operator">=</span> tl<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> BLOCK_SIZE_K<span class="token punctuation">)</span>
a_ptrs <span class="token operator">=</span> a_ptr <span class="token operator">+</span> <span class="token punctuation">(</span>offs_am<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span> <span class="token operator">*</span> stride_am <span class="token operator">+</span> offs_k<span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">*</span> stride_ak<span class="token punctuation">)</span>
b_ptrs <span class="token operator">=</span> b_ptr <span class="token operator">+</span> <span class="token punctuation">(</span>offs_k<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span> <span class="token operator">*</span> stride_bk <span class="token operator">+</span> offs_bn<span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">*</span> stride_bn<span class="token punctuation">)</span>
</code></pre><p>以第一个block为例：</p>
<ul>
<li>a_ptr：A矩阵的第一个元素的地址</li>
<li>b_ptr: B矩阵的第一个元素的地址</li>
<li>offs_am：A矩阵9个block中的第一个block中每个元素在整个A矩阵中的行坐标</li>
<li>offs_bn：B矩阵9个block中的第一个block中每个元素在整个B矩阵中的列坐标</li>
<li>offs_k：A矩阵的列坐标，B矩阵的行坐标</li>
</ul>
<p>有了行列坐标之后，和stride相乘，即可以得到每个元素的坐标a_ptr和b_ptrs</p>
<p>有了具体的坐标之后，进行乘加运算</p>
<pre data-role="codeBlock" data-info="python" class="language-python python"><code><span class="token comment"># -----------------------------------------------------------</span>
<span class="token comment"># Iterate to compute a block of the C matrix.</span>
<span class="token comment"># We accumulate into a `[BLOCK_SIZE_M, BLOCK_SIZE_N]` block</span>
<span class="token comment"># of fp32 values for higher accuracy.</span>
<span class="token comment"># `accumulator` will be converted back to fp16 after the loop.</span>
accumulator <span class="token operator">=</span> tl<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>BLOCK_SIZE_M<span class="token punctuation">,</span> BLOCK_SIZE_N<span class="token punctuation">)</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>tl<span class="token punctuation">.</span>float32<span class="token punctuation">)</span>
<span class="token keyword keyword-for">for</span> k <span class="token keyword keyword-in">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> tl<span class="token punctuation">.</span>cdiv<span class="token punctuation">(</span>K<span class="token punctuation">,</span> BLOCK_SIZE_K<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># Load the next block of A and B, generate a mask by checking the K dimension.</span>
    <span class="token comment"># If it is out of bounds, set it to 0.</span>
    a <span class="token operator">=</span> tl<span class="token punctuation">.</span>load<span class="token punctuation">(</span>a_ptrs<span class="token punctuation">,</span> mask<span class="token operator">=</span>offs_k<span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> K <span class="token operator">-</span> k <span class="token operator">*</span> BLOCK_SIZE_K<span class="token punctuation">,</span> other<span class="token operator">=</span><span class="token number">0.0</span><span class="token punctuation">)</span>
    b <span class="token operator">=</span> tl<span class="token punctuation">.</span>load<span class="token punctuation">(</span>b_ptrs<span class="token punctuation">,</span> mask<span class="token operator">=</span>offs_k<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> K <span class="token operator">-</span> k <span class="token operator">*</span> BLOCK_SIZE_K<span class="token punctuation">,</span> other<span class="token operator">=</span><span class="token number">0.0</span><span class="token punctuation">)</span>
    <span class="token comment"># We accumulate along the K dimension.</span>
    accumulator <span class="token operator">+=</span> tl<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
    <span class="token comment"># Advance the ptrs to the next K block.</span>
    a_ptrs <span class="token operator">+=</span> BLOCK_SIZE_K <span class="token operator">*</span> stride_ak
    b_ptrs <span class="token operator">+=</span> BLOCK_SIZE_K <span class="token operator">*</span> stride_bk
</code></pre><p>mask的作用是当K不能被BLOCK_SIZE_K整除时，到每一行最后一个block时，实际大小不足BLOCK_SIZE_K，需要使用mask遮蔽掉</p>
<pre data-role="codeBlock" data-info="python" class="language-python python"><code>accumulator <span class="token operator">+=</span> tl<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
</code></pre><p>计算了一个block的值之后移动到下一个block的元素</p>
<pre data-role="codeBlock" data-info="python" class="language-python python"><code>a_ptrs <span class="token operator">+=</span> BLOCK_SIZE_K <span class="token operator">*</span> stride_ak
b_ptrs <span class="token operator">+=</span> BLOCK_SIZE_K <span class="token operator">*</span> stride_bk
</code></pre><p>经过计算第一个C中的block后，写回到DRAM中，即完成了第一个block的全部操作</p>
<pre data-role="codeBlock" data-info="python" class="language-python python"><code><span class="token comment"># -----------------------------------------------------------</span>
<span class="token comment"># Write back the block of the output matrix C with masks.</span>
offs_cm <span class="token operator">=</span> pid_m <span class="token operator">*</span> BLOCK_SIZE_M <span class="token operator">+</span> tl<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> BLOCK_SIZE_M<span class="token punctuation">)</span>
offs_cn <span class="token operator">=</span> pid_n <span class="token operator">*</span> BLOCK_SIZE_N <span class="token operator">+</span> tl<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> BLOCK_SIZE_N<span class="token punctuation">)</span>
c_ptrs <span class="token operator">=</span> c_ptr <span class="token operator">+</span> stride_cm <span class="token operator">*</span> offs_cm<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span> <span class="token operator">+</span> stride_cn <span class="token operator">*</span> offs_cn<span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span>
c_mask <span class="token operator">=</span> <span class="token punctuation">(</span>offs_cm<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> M<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>offs_cn<span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> N<span class="token punctuation">)</span>
tl<span class="token punctuation">.</span>store<span class="token punctuation">(</span>c_ptrs<span class="token punctuation">,</span> c<span class="token punctuation">,</span> mask<span class="token operator">=</span>c_mask<span class="token punctuation">)</span>
</code></pre><p>在上述的program基础上，叠加上program的并行化，81个block经过81个program计算后得到了完整的C矩阵。</p>
<h2 id="references">References </h2>
<ul>
<li><a href="https://triton-lang.org/main/getting-started/tutorials/03-matrix-multiplication.html#sphx-glr-getting-started-tutorials-03-matrix-multiplication-py">Triton tutorial matrix multiplication</a> 必看</li>
<li><a href="https://www.zhihu.com/question/622685131">Triton编程入门 by 董鑫​</a> 高质量</li>
</ul>

      </div>
      
      
    
    
    
    
    
    
  
    </body></html>